"""API routes for deals."""

import logging
from datetime import datetime, timedelta, timezone
from decimal import Decimal
from typing import Optional, List
from fastapi import APIRouter, Query, Depends, HTTPException

from src.api.models import (
    DealCard,
    DealsFeedResponse,
    MarketOverview,
)
from src.core.models import (
    ConfidenceLevel,
    EventType,
    EventSource,
    Trend,
    BLACK_PACK_BACKGROUNDS,
)
from src.storage.db_pool import get_db_pool, DatabasePool

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/deals", tags=["deals"])


def _compute_quality_badge(
    profit_pct: Decimal,
    liquidity_score: Decimal,
    confidence_level: ConfidenceLevel,
    hotness: Decimal,
    is_black_pack: bool,
) -> Optional[str]:
    """Compute quality badge for a deal."""
    # BLACK_PACK always gets badge
    if is_black_pack:
        return "BLACK_PACK"

    # HOT: hotness > 7
    if hotness >= 7:
        return "HOT"

    # GEM: high liquidity + good profit + decent confidence
    if (
        liquidity_score >= 5
        and profit_pct >= 20
        and confidence_level in [ConfidenceLevel.HIGH, ConfidenceLevel.VERY_HIGH]
    ):
        return "GEM"

    # SNIPER: perfect combination
    if (
        profit_pct >= 25
        and liquidity_score >= 7
        and confidence_level == ConfidenceLevel.VERY_HIGH
        and hotness >= 6
    ):
        return "SNIPER"

    return None


@router.get("/feed", response_model=DealsFeedResponse)
async def get_deals_feed(
    page: int = Query(0, ge=0),
    page_size: int = Query(50, ge=1, le=100),
    sort_by: str = Query("smart", regex="^(smart|profit|hotness|time|liquidity)$"),
    min_profit: Optional[float] = Query(None, ge=0),
    max_price: Optional[Decimal] = Query(None, ge=0),
    black_pack_only: bool = Query(False),
    priority_only: bool = Query(False),
    db: DatabasePool = Depends(get_db_pool),
) -> DealsFeedResponse:
    """
    Get deals feed with filtering and sorting.

    Smart sorting formula:
    score = (profit * 0.4) + (liquidity * 0.3) + (confidence_weight * 0.2) + (hotness * 0.1)
    """
    # Build query
    filters = []
    params = {}

    # Time window: last 2 hours
    time_threshold = datetime.now(timezone.utc) - timedelta(hours=2)
    filters.append("me.event_time >= :time_threshold")
    params["time_threshold"] = time_threshold

    # Only listing and change_price events
    filters.append("me.event_type IN ('listing', 'change_price')")

    # Min profit filter
    if min_profit is not None:
            filters.append("aa.profit_pct >= :min_profit")
            params["min_profit"] = min_profit

        # Max price filter
        if max_price is not None:
            filters.append("me.price <= :max_price")
            params["max_price"] = max_price

        # Black pack filter
        if black_pack_only:
            filters.append("me.backdrop IN :black_pack_backgrounds")
            params["black_pack_backgrounds"] = tuple(BLACK_PACK_BACKGROUNDS)

        where_clause = " AND ".join(filters) if filters else "1=1"

        # Sorting
        if sort_by == "smart":
            # Smart score: profit*0.4 + liquidity*0.3 + confidence_weight*0.2 + hotness*0.1
            # Confidence weights: VERY_HIGH=10, HIGH=7, MEDIUM=4, LOW=1
            order_clause = """
                (
                    (aa.profit_pct * 0.4) +
                    (aa.liquidity_score * 3.0) +
                    (CASE
                        WHEN aa.confidence_level = 'very_high' THEN 10
                        WHEN aa.confidence_level = 'high' THEN 7
                        WHEN aa.confidence_level = 'medium' THEN 4
                        ELSE 1
                    END * 0.2) +
                    (aa.hotness * 0.1)
                ) DESC
            """
        elif sort_by == "profit":
            order_clause = "aa.profit_pct DESC"
        elif sort_by == "hotness":
            order_clause = "aa.hotness DESC"
        elif sort_by == "liquidity":
            order_clause = "aa.liquidity_score DESC"
        elif sort_by == "time":
            order_clause = "me.event_time DESC"
        else:
            order_clause = "me.event_time DESC"

        # Query to get deals with analytics
        query = f"""
            WITH latest_events AS (
                SELECT DISTINCT ON (me.gift_id)
                    me.event_time,
                    me.event_type,
                    me.gift_id,
                    me.gift_name,
                    me.model,
                    me.backdrop,
                    me.pattern,
                    me.number,
                    me.price,
                    me.photo_url,
                    me.source,
                    aa.profit_pct,
                    aa.reference_price,
                    aa.reference_type,
                    aa.confidence_level,
                    aa.liquidity_score,
                    aa.hotness,
                    aa.sales_48h
                FROM market_events me
                LEFT JOIN asset_analytics aa ON me.asset_key = aa.asset_key
                WHERE {where_clause}
                ORDER BY me.gift_id, me.event_time DESC
            )
            SELECT *
            FROM latest_events
            WHERE profit_pct IS NOT NULL AND profit_pct > 0
            ORDER BY {order_clause}
            LIMIT :limit OFFSET :offset
        """

        params["limit"] = page_size
        params["offset"] = page * page_size

        result = await db.pool.fetch(query, **params)

        # Convert to DealCards
        deals = []
        for row in result:
            backdrop = row["backdrop"]
            is_black_pack = backdrop in BLACK_PACK_BACKGROUNDS

            # Compute quality badge
            quality_badge = _compute_quality_badge(
                profit_pct=row["profit_pct"] or Decimal(0),
                liquidity_score=row["liquidity_score"] or Decimal(0),
                confidence_level=ConfidenceLevel(row["confidence_level"] or "low"),
                hotness=row["hotness"] or Decimal(0),
                is_black_pack=is_black_pack,
            )

            # Determine if priority
            is_priority = (row["hotness"] or 0) >= 7 or (row["profit_pct"] or 0) >= 25

            # Skip priority filter if enabled
            if priority_only and not is_priority:
                continue

            # Create asset_key
            backdrop_key = backdrop if backdrop else "no_bg"
            model_key = row["model"] if row["model"] else "no_model"
            asset_key = f"{model_key}:{backdrop_key}"

            deal = DealCard(
                asset_key=asset_key,
                gift_id=row["gift_id"],
                gift_name=row["gift_name"] or "Unknown",
                model=row["model"],
                backdrop=backdrop,
                pattern=row["pattern"],
                number=row["number"],
                photo_url=row["photo_url"],
                price=row["price"],
                reference_price=row["reference_price"] or Decimal(0),
                reference_type=row["reference_type"] or "unknown",
                profit_pct=row["profit_pct"] or Decimal(0),
                confidence_level=ConfidenceLevel(row["confidence_level"] or "low"),
                liquidity_score=row["liquidity_score"] or Decimal(0),
                hotness=row["hotness"] or Decimal(0),
                sales_48h=row["sales_48h"] or 0,
                event_type=EventType(row["event_type"]),
                event_time=row["event_time"],
                source=EventSource(row["source"]),
                is_black_pack=is_black_pack,
                is_priority=is_priority,
                quality_badge=quality_badge,
            )
            deals.append(deal)

        # Get total count
        count_query = f"""
            SELECT COUNT(DISTINCT me.gift_id)
            FROM market_events me
            LEFT JOIN asset_analytics aa ON me.asset_key = aa.asset_key
            WHERE {where_clause}
                AND aa.profit_pct IS NOT NULL
                AND aa.profit_pct > 0
        """
        total = await db.pool.fetchval(count_query, **params)

        return DealsFeedResponse(
            deals=deals,
            total=total or 0,
            page=page,
            page_size=page_size,
            has_more=(page + 1) * page_size < (total or 0),
        )

    finally:
        await db.disconnect()


@router.get("/overview", response_model=MarketOverview)
async def get_market_overview(
    db: PostgresStorage = Depends(get_postgres),
) -> MarketOverview:
    """Get market overview statistics."""
    await db.connect()

    try:
        # Time window: last 2 hours
        time_threshold = datetime.now(timezone.utc) - timedelta(hours=2)

        # Count active deals
        active_deals_query = """
            SELECT COUNT(DISTINCT gift_id)
            FROM market_events
            WHERE event_time >= :time_threshold
                AND event_type IN ('listing', 'change_price')
        """
        active_deals = await db.pool.fetchval(
            active_deals_query, time_threshold=time_threshold
        )

        # Count hot deals (hotness >= 7)
        hot_deals_query = """
            SELECT COUNT(DISTINCT me.gift_id)
            FROM market_events me
            LEFT JOIN asset_analytics aa ON me.asset_key = aa.asset_key
            WHERE me.event_time >= :time_threshold
                AND me.event_type IN ('listing', 'change_price')
                AND aa.hotness >= 7
        """
        hot_deals = await db.pool.fetchval(
            hot_deals_query, time_threshold=time_threshold
        )

        # Count priority deals
        priority_deals_query = """
            SELECT COUNT(DISTINCT me.gift_id)
            FROM market_events me
            LEFT JOIN asset_analytics aa ON me.asset_key = aa.asset_key
            WHERE me.event_time >= :time_threshold
                AND me.event_type IN ('listing', 'change_price')
                AND (aa.hotness >= 7 OR aa.profit_pct >= 25)
        """
        priority_deals = await db.pool.fetchval(
            priority_deals_query, time_threshold=time_threshold
        )

        # Get black pack floor (2nd lowest)
        black_pack_floor_query = """
            SELECT price
            FROM active_listings
            WHERE backdrop IN :black_pack_backgrounds
            ORDER BY price ASC
            LIMIT 1 OFFSET 1
        """
        black_pack_floor = await db.pool.fetchval(
            black_pack_floor_query,
            black_pack_backgrounds=tuple(BLACK_PACK_BACKGROUNDS),
        )

        # Get general floor (2nd lowest, excluding black pack)
        general_floor_query = """
            SELECT price
            FROM active_listings
            WHERE backdrop NOT IN :black_pack_backgrounds
            ORDER BY price ASC
            LIMIT 1 OFFSET 1
        """
        general_floor = await db.pool.fetchval(
            general_floor_query,
            black_pack_backgrounds=tuple(BLACK_PACK_BACKGROUNDS),
        )

        # Simple trend detection: compare avg price last hour vs previous hour
        trend = Trend.STABLE
        trend_query = """
            SELECT
                AVG(CASE WHEN event_time >= :hour_ago THEN price END) as recent_avg,
                AVG(CASE WHEN event_time < :hour_ago AND event_time >= :two_hours_ago THEN price END) as prev_avg
            FROM market_events
            WHERE event_type = 'buy'
                AND event_time >= :two_hours_ago
        """
        hour_ago = datetime.now(timezone.utc) - timedelta(hours=1)
        two_hours_ago = datetime.now(timezone.utc) - timedelta(hours=2)

        trend_result = await db.pool.fetchrow(
            trend_query, hour_ago=hour_ago, two_hours_ago=two_hours_ago
        )
        if trend_result and trend_result["recent_avg"] and trend_result["prev_avg"]:
            recent_avg = float(trend_result["recent_avg"])
            prev_avg = float(trend_result["prev_avg"])
            change_pct = ((recent_avg - prev_avg) / prev_avg) * 100

            if change_pct > 5:
                trend = Trend.RISING
            elif change_pct < -5:
                trend = Trend.FALLING

        return MarketOverview(
            active_deals=active_deals or 0,
            hot_deals=hot_deals or 0,
            priority_deals=priority_deals or 0,
            black_pack_floor=black_pack_floor,
            general_floor=general_floor,
            market_trend=trend,
            last_updated=datetime.now(timezone.utc),
        )

    finally:
        await db.disconnect()
